name: Build, Push and Deploy to Kubernetes

on:
  push:
    branches:
      - main # Trigger action on pushes to main branch
      - dev
    # paths-ignore:
    #   - "k8s/**"
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
       - name: Checkout repository
         uses: actions/checkout@v3

       - name: Set up Python
         uses: actions/setup-python@v4
         with:
           python-version: '3.x'
   
       - name: Set up Docker Buildx
         uses: docker/setup-buildx-action@v2
   
       - name: Log in to Docker container Registry
         uses: docker/login-action@v3
         with:
           username: ${{ secrets.DOCKERHUB_USERNAME }}
           password: ${{ secrets.DOCKERHUB_TOKEN }}

       - name: Build Docker image backend
         run: |
             docker build -f benefits.dev/backend/app.Dockerfile  -t fledxy/benefits-backend:${{ github.sha }} ./benefits.dev/backend
             
       - name: Build Docker image frontend
         run: |
             docker build -f benefits.dev/frontend/app.Dockerfile  -t fledxy/benefits-frontend:${{ github.sha }} ./benefits.dev/frontend
             
       - name: Push Docker images to Docker hub
         run: |
             docker push fledxy/benefits-backend:${{ github.sha }}
             docker push fledxy/benefits-frontend:${{ github.sha }}

       - name: Tag Docker image as latest
         run: |
             docker tag fledxy/benefits-backend:${{ github.sha }} fledxy/benefits-backend:latest
             docker tag fledxy/benefits-frontend:${{ github.sha }} fledxy/benefits-frontend:latest

  deploy-infra:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: app.tf

    steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v1
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ secrets.AWS_REGION }} 

        - name: Terraform init
          run: terraform init -upgrade

        - name: Terraform plan for environment 
          run: terraform plan --var-file=envs/${{ github.ref_name }}.tfvars

        - name: Terraform apply for environment 
          run: terraform apply -auto-approve --var-file=envs/${{ github.ref_name }}.tfvars
  
  deploy-to-eks:
    needs: [build, deploy-infra]
    runs-on: ubuntu-latest

    steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Set up JDK 17 
          uses: actions/setup-java@v3
          with: 
            java-version: '17'
            distribution: 'temurin'

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v1
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ secrets.AWS_REGION }} 

        - name: SonarQube Scan
          env:
            SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          run: |
              wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
              unzip sonar-scanner-cli-5.0.1.3006-linux.zip
              export PATH="$PATH:$(pwd)/sonar-scanner-5.0.1.3006-linux/bin"
              sonar-scanner \
                -Dsonar.projectKey=fledxy_benefits_aws\
                -Dsonar.organization=fledxy \
                -Dsonar.sources=. \
                -Dsonar.host.url=https://sonarcloud.io \
                -Dsonar.login=$SONAR_TOKEN

        - name: Access to eks cluster
          run: |
              aws eks create-access-entry --cluster-name ${{ secrets.EKS_CLUSTER_NAME }} --principal-arn ${{ secrets.AWS_USER_ARN }} --type STANDARD --user ${{ secrets.AWS_USERNAME }} --kubernetes-groups Viewers --region ${{ secrets.AWS_REGION }}

              aws eks associate-access-policy --cluster-name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --principal-arn ${{ secrets.AWS_USER_ARN }}  --access-scope type=cluster  --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy

        - name: Update kube config
          run: aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
        
        - name: Create namespace for branch
          run: |
            kubectl create namespace benefits-${{ github.ref_name }} --dry-run=client -o yaml | kubectl apply -f -
            
        - name: Deploy PostgreSQL using Helm
          run: |
            helm uninstall postgres --namespace benefits-${{ github.ref_name }} || true
            helm install postgres k8s/postgres -f k8s/postgres/values.yaml --namespace benefits-${{ github.ref_name }}
            
        - name: Create database connection secret
          run: |
              kubectl create secret generic postgres-secret -n benefits-dev \
              --from-literal=POSTGRES_USER=benefits \
              --from-literal=POSTGRES_PASSWORD=postgres \
              --from-literal=POSTGRES_DB=benefits_db
        
        - name: Deploy Backend using Kustomize
          run: |
            cd k8s/backend
            kustomize edit set namespace benefits-${{ github.ref_name }}
            kustomize edit set image fledxy/fledxy_application=fledxy/benefits-backend:${{ github.sha }}
            
            # Set domain based on branch
            if [ "${{ github.ref_name }}" = "main" ]; then
              DOMAIN="fledxy.com"
            else
              DOMAIN="dev.fledxy.com"
            fi
            
            # Update backend configmap
            sed -i "s|CORS_ORIGINS:.*|CORS_ORIGINS: \"https://benefits.$DOMAIN\"|" configmap.yaml
            kubectl apply -k .
            
        - name: Deploy Frontend using Kustomize
          run: |
            cd k8s/frontend
            kustomize edit set namespace benefits-${{ github.ref_name }}
            kustomize edit set image fledxy/fledxy_application=fledxy/benefits-frontend:${{ github.sha }}
            
            # Set domain based on branch
            if [ "${{ github.ref_name }}" = "main" ]; then
              DOMAIN="fledxy.com"
            else
              DOMAIN="dev.fledxy.com"
            fi
            
            # Update frontend configmap
            sed -i "s|DOMAIN:.*|DOMAIN: \"$DOMAIN\"|" configmap.yaml
            kubectl apply -k .
        
        - name: Deploy Ingress and Network Policy
          run: |
            # Set domain based on branch
            if [ "${{ github.ref_name }}" = "main" ]; then
              DOMAIN="fledxy.com"
            else
              DOMAIN="dev.fledxy.com"
            fi
            
            # Replace domain in ingress.yaml and network-policy.yaml
            sed -i "s/\$(DOMAIN)/$DOMAIN/g" k8s/ingress.yaml
            sed -i "s/\$(DOMAIN)/$DOMAIN/g" k8s/network-policy.yaml
            
            # Apply ingress and network policy
            kubectl apply -f k8s/ingress.yaml --namespace benefits-${{ github.ref_name }}
            kubectl apply -f k8s/network-policy.yaml --namespace benefits-${{ github.ref_name }}

        - name: Install ArgoCD server
          run: |
            kubectl create namespace argocd
            helm repo add argo https://argoproj.github.io/argo-helm
            helm install argocd argo/argo-cd --namespace argocd   

  monitoring:
    needs: [build, deploy-infra, deploy-to-eks]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kube config
        run: aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

      - name: Create monitoring namespace
        run: kubectl create namespace monitoring

      - name: Update monitoring chart values
        run: |
          # Set domain based on branch
          if [ "${{ github.ref_name }}" = "main" ]; then
            DOMAIN="fledxy.com"
          else
            DOMAIN="dev.fledxy.com"
          fi
          
          # Update values.yaml with environment-specific settings
          sed -i "s/domain: example.com/domain: $DOMAIN/" k8s/monitoring/values.yaml
          sed -i "s/grafana.example.com/grafana.$DOMAIN/" k8s/monitoring/values.yaml
          
          # Update Grafana admin credentials
          sed -i "s/admin: admin/admin: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}/" k8s/monitoring/values.yaml

      - name: Install monitoring stack
        run: |
          helm uninstall monitoring --namespace monitoring || true
          helm upgrade --install monitoring ./k8s/monitoring --namespace monitoring
      
      - name: Verify monitoring stack deployment
        run: |
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=prometheus -n monitoring --timeout=300s
          kubectl wait --for=condition=ready pod -l app=grafana -n monitoring --timeout=300s
          kubectl wait --for=condition=ready pod -l app=loki -n monitoring --timeout=300s
          kubectl wait --for=condition=ready pod -l app=alertmanager -n monitoring --timeout=300s
  